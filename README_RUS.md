# Git cheats

[`English`](./README.md) [`Русский`](./README_RUS.md)

Быстрый обзор основных команд для работы с системой контроля версий Git.

## Содержание

  - [Базовые команды](#базовые-команды)
  - [Вывод информации о коммитах](#вывод-информации-о-коммитах)
  - [Работа с ветками](#работа-с-ветками)
  - [Удаленные репозитории](#удаленные-репозитории)
  - [Отложенные (спрятанные) коммиты](#отложенные-спрятанные-коммиты)
  - [Удаления коммитов и откаты](#удаления-коммитов-и-откаты)
  - [Дополнительные и похожие ресурсы](#дополнительные-и-похожие-ресурсы)

## Базовые команды

**Репозиторий (Repository)** - место, где хранится исходный код и история изменений вашего проекта. Репозиторий может быть локальным (на вашем компьютере) или удаленным (на сервере).

```shell
git init # Инициализация нового репозитория
```

```shell
git status # Показать статус файлов в текущем репозитории
```

-   **Неотслеживаемые файлы (Untracked)** - Git не знает о существовании этих файлов, поэтому никак на них не влияет.
-   **Измененные файлы (Modified)** - эти файлы уже ранее были добавлены для отслеживания и теперь Git обнаружил, что их содержимое изменились по сравнению с последним коммитом.
-   **Файлы в индексе (Staged)** - это промежуточное состояние файлов, которые были ранее Untracked или Modified, а теперь они зафиксированы и готовы к включению в новый коммит.

```shell
git add . # Добавить все файлы Untracked и Modified в индекс
git add file.name # Добавить только определенный файл
git add ./**/*.js # Добавить все файлы с расширением .js
```

```shell
git rm file.name # Убрать добавленный файл из индекса
git reset file.name # Аналогично команде выше
```

**Коммит (Commit)** - запись в истории репозитория, которая представляет информацию об изменениях в файлах. Каждый коммит имеет уникальный идентификатор (хэш) и некоторые метаданные.

```shell
git commit -m "comment" # Зафиксировать новый коммит с указанным сообщением
git commit --amend -m "Updated message" # Перезаписать сообщение для последнего коммита
git commit --amend --no-edit # Довнести измнения в последний коммит
```

```shell
git tag <tag_name> <commit_hash> # Добавить тэг (алиас) для коммита.
# Теперь этот тег можно использовать вместо хэша для обращения к определенному коммиту.
git tag # Вывести список доступных тегов
```

```shell
git mv <path/to/file> <new/path/to/file> # Перемещение файла (частный случай переименовывания)
```

```shell
git restore file.name # Отменить изменения в файле, который ещё не был зафиксирован
git checkout file.name # Аналогично команде выше (устаревший подход)
```

## Вывод информации о коммитах

```shell
git log # Вывести историю коммитов
git log -3 # Вывести три последних коммита
git log --oneline # Вывод истории в одну строку для каждого коммита
git reflog # Информация о коммитах и о произведенных действиях (храниться только у Вас локально)
```

```shell
git show <commit_hash> # Показать информацию о коммите
git diff <commit_hash> # Показать разницу между выбранным коммитом и текущим состоянием
git diff <commit_hash> <commit_hash> # Показать разницу между двумя коммитами
git diff <file_name> # Показать изменения выбранного файла
```

## Работа с ветками

**Ветка (Branch)** - последовательность коммитов. Как правило в репозитории существует одна основная ветка (Master/Main branch). От этой ветки (из любого её коммита) можно "ответвляться", то есть начинать новые независимые ветки, в которых можно разрабатывать, какой-то новый функционал, фиксируя всё новые и новые коммиты.

```shell
git branch # Вывести список доступных веток и текущей
git checkout -b <branch_name> # Создать новую ветку из текущей и сразу на неё перейти
git checkout - # Быстрое переключение на предыдущую ветку
git branch <branch_name> # Переключиться на другую ветку
git branch <new_branch_name> <commit_hash> # Создать ветку из определенного коммита
```

**Слияние (Merge)** - процесс объединения изменений из одной ветки в другую.

```bash
git merge <branch_name> # Объединить текущую ветку с указанной (со всеми её коммитами)
git merge --squash <branch_name> # Аналогично команде выше, только все коммиты будут слиты в один итоговый
git cherry-pick <commit_hash> # Объединить текущую ветку с коммитом из другой ветки
git rebase <branch_name> # Актуализировать историю коммитов и интегрировать изменения из указанной ветки
git branch -d <branch_name> # Удалить ветку
```

**Конфликт слияния (Merge conflict)** - ситуация при слиянии, когда две ветки имеют разные изменения в одном и том же месте, и Git не может автоматически объединить их.

-   [**Обзор комманты git cherry-pick**](https://www.atlassian.com/ru/git/tutorials/cherry-pick)
-   [**Git rebase — перебазирование коммитов и веток**](https://selectel.ru/blog/tutorials/how-to-rebase-commits-and-branches/)

## Удаленные репозитории

```shell
git remote add origin <URL> # Подкючиться к удаленному репозиторию и дать ему имя origin
git push --set-upstream origin <branch_name> # Подключить ветку к origin
git push # Отправить изменения в удаленный репозиторий
git pull # Скачать изменения из удаленного репозитория и сразу слить в локальную ветку
git fetch # Только скачать изменения из удаленного репозитория без автоматического слияния
# (это позволит вам изучить загруженный код и уже самим решить как его объединить с локальным)
git push -u origin <branch_name> # Отправить новую ветку в удаленный репозиторий
git push --delete origin <branch_name> # Удалить ветку из удаленного репозитория
git remote remove origin # Удалить подключение к удаленному рапозиторию origin
git remote -v # Показать список подключенных удаленных репозиториев
```

-   [**Git push - что такое и как использовать - отправка изменений, публикация, работы с тегами и коммитами**](https://selectel.ru/blog/tutorials/what-is-git-push-and-how-to-use-it/)
-   [**Команда git fetch — чем отличается от git pull**](https://selectel.ru/blog/tutorials/git-fetch-command-how-is-it-different-from-git-pull/)

## Отложенные (спрятанные) коммиты

**Git stash** позволяет временно сохранить текущие незафиксированные изменения в специальной области, так называемой `stash (тайник)`. Это удобно, когда вы хотите переключиться на другую задачу или ветку, но не хотите коммитить незавершенные изменения. Позже вы можете применить сохраненные изменения обратно к своей рабочей копии.

```shell
git stash save "message" # Сохранить текущие назафиксированные изменения в stash с указанным сообщением
git stash list # Посмотреть список всех сохраненных stash'ей
git stash apply # Достать последние сохраненные изменения из stash, оставляя копию в stash
git stash apply <stash_number> # Достать сохраненные изменения из stash по его порядковому номеру, оставляя копию в stash
git stash pop # Достать последние сохраненные изменения из stash и удалить их копию из stash
git stash clear # Очистить stash
```

## Удаления коммитов и откаты

```bash
git reset <commit_hash> # Удалить все фиксации коммитов до указанного.
# Все изменения из удаленных коммитов теперь можно фиксировать заново.
# (например, чтобы создать один общий коммит)
git reset --hard # Удалить все незафиксированные изменения и изменения
# добавленные в индекс, но еще не зафиксированные коммитом
git revert <commit_hash> # Создать новый коммит, который отменяет изменения сделанные в указанном коммите
# (безопасный способ откатывать изменения, сохраняя всю историю)
```

-   [**3 режима команды git reset: soft, mixed и hard** - Хабр (habr.com)](https://habr.com/ru/articles/203282/)

## Дополнительные и похожие ресурсы

-   [**Git официальная документация**](https://git-scm.com/docs)
-   [**Pro Git - подробная книга о Git на русском**](https://git-scm.com/book/ru/v2)
-   [**Практический видеокурс о Git** - YouTube](https://youtu.be/SEvR78OhGtw)
